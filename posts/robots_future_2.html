<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>gama's ramblings - Designing Robots Futures - Part 2</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <link rel="stylesheet" href="../css/code.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">gama's ramblings</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Designing Robots Futures - Part 2</h1>
            <div class="info">
    Posted on January 16, 2016
    
</div>

<h1 id="some-issues.">Some issues.</h1>
<p>We mentionned what we wanted, let’s talk about some of theproblem we might encounter during the design.</p>
<p>First there is a rather obvious lifetime issue. Indeed as we said last time we want to be able to free the thread as soon as possible (when returning from the <code>receive</code> function) and thus simply tell the future what it should be doing when the answer is received.</p>
<p>Thus when the future that the <code>ask</code> method gives us is dropped, the information we gave it must not be lost.</p>
<p>The second lifetime issue is the can be simply seen in the folowing case:</p>
<ul>
<li>Actor A asks something to Actor B.</li>
<li>In his future, the closure takes the context (it is clonable), and uses some methods of it when it will be completed.</li>
<li>Actor A is terminated for some reason.</li>
<li>Actor B receives the message and answers.</li>
<li>The closure is called and tries to use the context of a no longer existing actor (A).</li>
</ul>
<p>Now this is hopefuly not to bad, as ActorCell can kinda gracefuly handle themselve when the actor has been dropped.</p>
<p>A question that might be asked from this is whether or not Actor A should be kept alive or not as long as a future it spawned is alive ?</p>
<p>Now another thing that we may want would be to be able to do the following:</p>
<p>````rust let future = some_actor_ref.ask(());</p>
<p>let x = future.do(|| {//…}); // y’s closure is launched at about the same time as x’s, and gets the same value as input. let y = future.do(|| {//…}); ```</p>
<p>This seems like a nice to have but not incredbly necessary (we could try to reimplement <a href="https://github.com/carllerche/eventual">eventual</a>’s <code>Async</code>).</p>
<h2 id="handling-double-answers.">Handling double answers.</h2>
<p>Now we also need to handle the case were an actor answers twice to the mesage, what should happen in this case ?</p>
<p>The current design idea would be to have the actor fail, but not the future (as a future could only be completed once in theory) since the failure does not come from the Future.</p>

        </div>

        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
